# 프로세스와 스레드

- 프로세스
    - 컴퓨터에서 실행되고 있는 프로그램
    - CPU 스케쥴링의 대상이 되는 작업(task)과 거의 같은 의미
    - ex. HDD/SDD에 있는 프로그램이 메모리에 올라가면 프로세스가 되는 인스턴스화 발생 → 운형체제의 CPU 스케쥴러에 따라 CPU가 프로세스를 실행
- 스레드
    - 프로세스 내 작업의 흐름

# 프로세스와 컴파일 과정 (C언어 기반)

- 프로세스는 프로그램이 메모리에 올라가 인스턴스화된 것
ex. 구글 크롬 프로그램(chrome.exe)을 더블클릭하면 구글 크롬 프로세스로 변환
- 프로그램을 만드는 과정
    - 컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 번역하여 실행할 수 있는 파일을 만듦
    - 소스코드파일 → 전처리 → 컴파일러 → 어셈블리어 → 어셈블러 → 목적 코드
    라이브러리 + 목적코드 → 링커 → 실행 가능한 파일

## 전처리

- 소스코드의 주석을 제거하고 #include 등 헤더 파일을 병합하여 매크로를 치환

## 컴파일러

- 오류 처리, 코드 최적화 작업
- 어셈블리어로 변환

## 어셈블러

- 어셈블리어를 목적 코드(object code)로 변환

## 링커

- 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만듦

### 정적 라이브러리와 동적 라이브러리

- 정적 라이브러리
    - 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행파일에 넣는 방식으로 라이브러리를 쓰는 방법
    - 장점: 시스템 환경 등 외부 의존도가 낮다
    - 단점: 코드 중복 등 메모리 효율성이 떨어진다
- 동적 라이브러리
    - 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법
    - 장점: 메모리 효율성
    - 단점: 외부 의존도가 높아짐

# 프로세스의 상태

<img width="369" alt="스크린샷 2024-01-24 오후 3 10 00" src="https://github.com/MaryJo-github/CS-Study/assets/42026766/d0f97313-3aeb-4a29-8003-3c2ce48e8e44">

## 생성 상태 (create)

- 프로세스가 생성된 상태
- 이 때 PCB가 할당됨
- fork() 또는 exec() 함수를 통해 생성
    - fork(): 부모 프로세스의 주소 공간을 그대로 복사하며 새로운 자식 프로세스를 생성하는 함수
    - exec(): 새롭게 프로세스를 생성하는 함수

## 대기 상태 (ready)

- 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기
- CPU 스케쥴러로부터 CPU 소유권이 넘어오기를 기다리는 상태

## 대기 중단 상태 (ready suspended)

- 메모리 부족으로 일시 중단된 상태

## 실행 상태 (running)

- CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태
- CPU burst가 일어났다고도 표현
    - [burst](https://blog.naver.com/4717010/60210491494): 특정 기준에 따라 한 단위로서 취급되는 연속된 신호 또는 데이터의 모임. 어떤 현상이 짧은 시간에 집중적으로 일어나는 현상. 또는 주기억 장치의 내용을 캐시 기억 장치에 블록 단위로 한꺼번에 전송하는 것.

## 중단 상태 (blocked)

- 프로세스가 차단된 상태
- I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 함
ex. 프린트 인쇄 버튼을 눌렀을 때 프로세스가 잠깐 멈춘 듯한 상태

## 일시 중단 상태 (blocked suspended)

- 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태

## 종료 상태 (terminated)

- 메모리와 CPU 소유권을 모두 놓고 가는 상태
- 자연스럽게 종료되는 것도 있지만 부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료(abort)도 가능. 자식 프로세스에 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process.kill 등의 명령어로 프로세스를 종료할 때 발생

# 프로세스의 메모리 구조

- 운영체제는 다음 구조를 기반으로 프로세스에 적절한 메모리를 할당

    <img width="275" alt="스크린샷 2024-01-24 오후 4 48 27" src="https://github.com/MaryJo-github/CS-Study/assets/42026766/8bf5576a-b47a-4eb2-9895-2d88b5be0b6c">
    
    - 스택은 작은 주소부터 할당, 힙은 큰 주소부터 할당됨

## 스택과 힙

- 동적 할당 (런타임 단계에서 메모리를 할당하는 것)
- 스택
    - 지역 변수, 매개변수, 실행되는 함수가 저장됨 (컴파일 시에 크기가 결정)
    - 재귀 함수가 호출되면 새로운 스택 프레임이 매번 생성
- 힙
    - 동적으로 할당되는 변수 (런타임 시에 크기가 결정)
    - malloc(), free() 함수를 통해 관리 가능
    - 동적으로 관리되는 자료 구조의 경우 힙 영역 사용
    ex. swift의 Array, Dictionary, Set, String과 같은 가변 길이 Collection들은 컴파일 타임에 사이즈를 정확히 알기 어렵기 때문에 Heap에 저장해서 사용
- Swift 관련 참고하면 좋은 링크: [Swift의 Type과 메모리 저장 공간](https://sujinnaljin.medium.com/ios-swift%EC%9D%98-type%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A0%80%EC%9E%A5-%EA%B3%B5%EA%B0%84-25555c69ccff)

## 데이터 영역과 코드 영역

- 정적 할당 (컴파일 단계에서 메모리를 할당하는 것)
- 데이터 영역
    - BSS segment: 전역 변수 또는 static, const로 선언되어 있고 0으로 초기화 또는 초기화가 어떠한 값으로도 되어 있지 않은 변수들이 저장됨
    - Data segment: 전역 변수 또는 static, const로 선언되어 있고 0이 아닌 값으로 초기화된 변수들이 저장됨
    - code segment: 프로그램의 코드가 저장됨

# PCB (Process Control Block)

- 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터
    - 메타데이터: 데이터에 관한 구조화된 데이터이자 데이터를 설명하는 작은 데이터. 대량의 정보 가운데 찾고 있는 정보를 효율적으로 찾아내기 위해서 일정한 규칙에 따라 콘텐츠에 대해 부여되는 데이터
- 프로세스 제어 블록이라고도 불림
- 프로세스가 생성되면 운영체제는 해당 PCB를 생성함
- 프로그램 실행 → 프로세스 생성 → 프로세스 주소 값들에 스택, 힙 등의 구조를 기반으로 메모리 할당 → 프로세스의 메타데이터들을 PCB에 저장
- 프로세스의 중요한 정보를 포함하기 때문에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리됨

## PCB의 구조

- 프로세스 스케줄링 상태: ‘준비’, ‘일시중단’ 등 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
- 프로세스 ID: 프로세스 ID, 해당 프로세스의 자식 프로세스 ID
- 프로세스 권한: 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
- 프로그램 카운터: 프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터
- CPU 레지스터: 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
- CPU 스케줄링 정보: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
- 계정 정보: 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
- I/O 상태 정보: 프로세스에 할당된 I/O 디바이스 목록

## 컨텍스트 스위칭 (context switching)

- 프로세스의 상태를 저장하고 로드시키는 과정
- 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생
- 컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이지만 어떠한 시점에서 실행되고 있는 프로세스는 단 한 개(싱글 코어 기준)이며, 많은 프로세스가 동시에 구동되는 것처럼 보이는 것은 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행되기 때문

![IMG_9B8D28DF6A7D-1](https://github.com/MaryJo-github/CS-Study/assets/42026766/5211c1d6-8340-4ade-93e5-3cfca6f3d424)

- 컨텍스트 스위칭이 일어날 때 드는 비용
    - 유휴시간(idle time)
    - 캐시미스: 프로세스가 가지고 있는 메모리 주소를 컨텍스트 스위칭할 때 그대로 가지고 있으면 잘못된 주소 변환이 생기므로 캐시를 지워주는 캐시클리어 과정을 거침. 근데 이 때문에 캐시미스가 발생
- 참고) 스레드에서도 컨텍스트 스위칭 발생
  - [스레드 컨텍스트 스위칭이 가벼운 이유](https://easy-code-yo.tistory.com/31)
