# 디자인 패턴

- 디자인 패턴이란 **프로그램을 설계할 때 발생했던 문제점들**을 객체 간의 상호 관계 등을 이용하여 **해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것**

## 📍싱글톤 패턴
- **정의**
    - **하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴**
- **장점**
    - 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어듦
- **단점**
    - 모듈 간의 결합을 강하게 만들 수 있음(의존성이 높아짐) → 의존성 주입으로 해결
    - 단위 테스트가 어려워짐
        - TDD(Test Driven Development)를 할 때 단위 테스트를 주로하는데, 단위 테스트는 테스트가 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 함. 하지만 싱글톤 패턴은 각 테스트 마다 ‘독립적인’ 인스턴스를 만들기 어려움
- **적용**
    - 클래스가 모든 클라이언트가 사용할 수 있는 단일 인스턴스만 있어야할 때 사용
        - 보통 데이터베이스 연결 모듈에 많이 사용
    - 전역 변수들을 더 엄격하게 제어해야 할 때 사용

### 의존성 주입(DI, Dependency Injection)
- 의존성(= 종속성)
    - A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A 또한 변해야 한다는 것을 의미
- 장점
    - 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스트 하기 쉬움
        - 모듈: 프로그램을 구성하는 구성 요소로, **관련된 데이터와 함수를 하나로 묶는 단위**
        - 모듈 vs 라이브러리 vs 프레임워크
            - 모듈: 별도의 파일로 분리된 독립된 기능
            - 라이브러리: 모듈이 프로그램을 구성하는 작은 부품의 느낌이라면, 라이브러리는 자주 사용되는 로직을 잘 정리한 집합 느낌
            - 프레임워크: 복잡한 문제를 해결하거나 서술하는 데에 사용되는 기본 개념 구조.
    - 마이그레이션하기도 수월함
    - 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 애플리케이션 의존성 방향이 일관되고 애플리케이션을 쉽게 추론할 수 있음
    - 모듈 간의 관계들이 조금 더 명확해짐
- 단점
    - 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있음
    - 약간의 런타임 패널티가 생기기도함

### 의존성 주입 원칙
- 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함
- 또한 둘 다 추상화에 의존해야 함
- 이 때, 추상화는 세부 사항에 의존하지 말아야 함

<br>

## 📍팩토리 패턴(팩토리 메서드 패턴)
- **정의**
    - 객체를 사용하는 코드에서 **객체 생성 부분을 떼어내 추상화한 패턴**
    - 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, **하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정**하는 패턴
- **장점**
    - 상위 클래스와 하위 클래스가 분리되기 때문에 **느슨한 결합**을 가짐
    - 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 코드를 리팩터링하더라도 한 곳만 고칠 수 있게 되니 **유지 보수성이 증가됨** (개방/폐쇄 원칙)
- **단점**
    - 패턴을 구현하기 위해 많은 새로운 하위 클래스들을 도입해야 하므로 코드가 더 복잡해질 수 있음
- **적용**
    - 함께 작동해야하는 객체들의 정확한 유형들과 의존관계들을 미리 모르는 경우 사용
    - 라이브러리 또는 프레임워크의 사용자들에게 내부 컴포넌트들을 확장하는 방법을 제공하고 싶을 때 사용
    - 기존 객체들을 매번 재구축하는 대신 이들을 재사용하여 시스템 리소스를 절약하고 싶을 때 사용

<br>

## 📍전략 패턴
- **정의**
    - 전략 패턴(strategy pattern)은 정책 패턴(policy pattern)이라고도 함
    - **객체의 행위를 바꾸고 싶은 경우** ‘직접’ 수정하지 않고 전략이라고 부르는 **‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는** 패턴(전략만 바꿈!)
        - **컨텍스트(context)**: 프로그래밍에서의 컨텍스트는 상황, 맥락, 문맥을 의미하여 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 말함
- **장점**
    - 런타임에 한 객체 내부에서 사용되는 알고리즘들을 교환할 수 있음
    - 알고리즘을 사용하는 코드에서 알고리즘의 구현 세부 정보들을 고립할 수 있음
    - 상속을 합성으로 대체할 수 있음
    - 콘텍스트를 변경하지 않고도 새로운 전략들을 도입할 수 있음(개방/폐쇄 원칙)
- **단점**
    - 알고리즘이 몇 개밖에 되지 않고 거의 변하지 않는다면, 패턴과 함께 사용되는 새로운 클래스들과 인터페이스들로 프로그램을 지나치게 복잡하게 만들 이유가 없음
    - 클라이언트들은 적절한 전략을 선택할 수 있도록 전략 간의 차이점들을 알고 있어야 함
- **적용**
    - 객체 내에서 한 알고리즘의 다양한 변형들을 사용하고 싶을 때, 그리고 런타임 중에 한 알고리즘에서 다른 알고리즘으로 전화하고 싶을 때 사용
    - 일부 행동을 실행하는 방식에서만 차이가 있는 유사한 클래스들이 많은 경우 사용
    - 클래스의 비즈니스 로직을 해당 로직의 콘텍스트에서 그리 중요하지 않을지도 모르는 알고리즘들의 구현 세부 사항들로부터 고립하세요
    - 같은 알고리즘의 다른 변형들 사이에 전환하는 거대한 조건문이 클래스에 있는 경우 사용

<br>

## 📍옵저버 패턴
- **정의**
    - 옵저버 패턴(observer pattern)은 주체가 **어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다** 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
        - 주체: 객체의 상태 변화를 보고 있는 관찰자
        - 옵저버: 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들
    - 주체와 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축하기도함
- **장점**
    - Publisher의 코드를 변경하지 않고도 새 구독자 클래스들을 도입할 수 있음(개방폐쇄 원칙)
    - 런타임에 객체 간의 관계들을 형성할 수 있음
- **단점**
    - 구독자들은 무작위로 알림을 받음
- **적용**
    - 한 객체의 상태가 변경되어 다른 객체들을 변경해야 할 필요성이 생겼을 때, 그리고 실제 객체 집합들을 미리 알 수 없거나 이러한 집합들이 동적으로 변경될 때 사용
    - 앱의 일부 객체들이 제한된 시간 동안 또는 특정 경우에만 다른 객체들을 관찰해야 할 때 사용

<br>

## 📍프록시 패턴
- **정의**
    - 프록시 패턴(proxy pattern)은 **대상 객체(subject)에 접근하기 전** 그 접근에 대한 흐름을 가로채 대상 객체 **앞단의 인터페이스 역할**을 하는 디자인 패턴
    - 이를 통해 객체 의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용
    - 이는 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용됨
- **장점**
    - 클라이언트들이 알지 못하는 상태에서 서비스 객체를 제어할 수 있음
    - 클라이언트들이 신경쓰지 않을 때 서비스 객체의 수명 주기를 관리할 수 있음
    - 프록시는 서비스 객체가 준비되지 않았거나 사용할 수 없는 경우에도 작동함
    - 서비스나 클라이언트들을 변경하지 않고도 새 프록시들을 도입할 수 있음(개방폐쇄원칙)
- **단점**
    - 새로운 클래스들을 많이 도입해야 하므로 코드가 복잡해질 수 있음
    - 서비스의 응답이 늦어질 수 있음
- **적용**
    - Lazy initialization (virtual proxy)
    - Access control (protection proxy)
    - Local execution of a remote service (remote proxy)
    - Logging requests (logging proxy)
    - Caching request results (caching proxy)
    - Smart reference

### 프록시 서버
- 프록시 서버(proxy server)는 **서버와 클라이언트 사이에서** 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킴
<aside>
💡 프록시 서버에서의 캐싱<br>
- 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것
- 이를 통해 불필요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있다는 장점이 있음
</aside>

<br>

## 📍이터레이터 패턴(반복자 패턴)
- **정의**
    - 이터레이터(iterator pattern)은 **이터레이터(iterator)를 사용하여 컬렉션(collection)의 요소들에 접근**하는 디자인 패턴
    - 이를 통해 순회할 수 있는 **여러 가지 자료형의 구조와는 상관없이** 이터레이터라는 **하나의 인터페이스로 순회 가능**
        - 이터레이터 프로토콜: 이터러블한 객체들을 순회할 때 쓰이는 규칙
        - 이터러블한 객체: 반복 가능한 객체로 배열을 일반화한 객체
- **장점**
    - 부피가 큰 순회 알고리즘들을 별도의 클래스들로 추출하여 클라이언트 코드와 컬렉션들을 정돈할 수 있음(단일 책임 원칙)
    - 새로운 유형의 컬렉션들과 반복자들을 구현할 수 있으며 이들을 아무것도 훼손하지 않은 체 기존의 코드에 전달할 수 있음(개방폐쇄 원칙)
    - 컬렉션을 병렬로 순회할 수 있음. 왜냐하면 각 반복자 객채에는 자신의 고유한 순회 상태가 포함되어 있기 때문)
- **단점**
    - 단순한 컬렉션들과만 작동하는 경우 반복자 패턴을 적용하는 것은 과도할 수 있음
    - 반복자를 사용하는 것은 일부 특수 컬렉션들의 요소들을 직접 탐색하는 것보다 덜 효율적일 수 있음
- **적용**
    - 컬렉션 내부에 복잡한 데이터 구조가 있지만 이 구조의 복잡성을 보안이나 편의상의 이유로 클라이언트들로부터 숨기고 싶을 때 사용
    - 앱 전체에서 순회 코드의 중복을 줄일 때
    - 다른 데이터 구조들을 순회할 수 있기를 원할 때나 이러한 구조들의 유형을 미리 알 수 없을 때

<br>

## 📍노출모듈 패턴
- 노출모듈 패턴(revealing module parttern)은 **즉시 실행 함수를 통해** private, public 같은 **접근 제어자를 만드는 패턴**
- 자바 스크립트는 private나 public 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행되기 때문에 노출모듈 패턴을 통해 접근 제어자를 구현하기도 함.

<br>
---

## 📍MVC 패턴
- Model, View, Controller로 이루어진 디자인 패턴
- 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있음
- 장점
    - 재사용성 과 확장성이 용이
- 단점
    - 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐

### 모델
- 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함

### 뷰
- 사용자 인터페이스 요소를 나타냄
- 즉, 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻함
- 모델이 가지고 있는 정보를 따로 저장하지 않아야하며 단순히 사각형 모양등 화면에 표시하는 정보만 가지고 있어야 함
- 또한 변경이 일어나면 컨트롤러에 이를 전달

### 컨트롤러
- 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당
- 모델과 뷰의 생명주기도 관리
- 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용을 알려줌

<br>

## 📍MVP 패턴
- MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴
    - Controller → Presenter
- 뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴

<br>

## 📍MVVM 패턴
- MVC의 C에 해당하는 컨트롤러가 뷰모델(View Model)로 바뀐 패턴
    - Controller → View Model
- 여기서 뷰모델은 뷰를 더 추상화한 계층이며, MVVM패턴은 MVC 패턴과 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징
    - 커맨드: 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
    - 데이터 바인딩: 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경됨
- 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원
- UI를 별도의 코드 수정없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있음
