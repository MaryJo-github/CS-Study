# 그래프

- 정점과 간선으로 이루어진 자료 구조

## 정점과 간선

- 어떠한 곳에서 어떠한 곳으로 무언가를 통해 간다고 했을 때,
’어떠한 곳’은 정점(vertex), ‘무언가’는 간선(edge)
- 정점으로 나가는 간선을 해당 정점의 outdegree
정점으로 들어오는 간선을 해당 정점의 indegree

※ 가중치: 간선과 정점 사이에 드는 비용

# 트리

- 그래프의 한 종류 (정점과 간선으로 이루어져 있음)
- 트리 구조로 배열된 계층적 데이터의 집합

## 특징

- 부모, 자식 계층 구조를 가짐
- 간선수 = 노드 수 - 1
- 트리 내의 임의의 두 노드 사이의 경로는 반드시 존재

## 구성

- 루프 노드, 내부 노드, 리프 노드

  ![1](https://github.com/MaryJo-github/CS-Study/assets/42026766/98790bac-69f5-4128-8165-a6962197670b)

    - 루프 노드
        - 가장 위에 있는 노드
        - 보통 트리 문제가 나왔을 때 루트 노드를 중심으로 탐색하면 쉽게 풀리는 경우가 많음
    - 내부 노드
        - 자식이 있는 모든 노드 (리프 노드가 아닌 노드)
    - 리프 노드
        - 자식 노드가 없는 노드

### ※ 트리의 높이와 레벨

- 깊이: 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리
- 높이: 루트 노드부터 리프 노트까지 거리 중 가장 긴 거리
- 레벨: 깊이와 같은 의미
- 서브트리: 트리 내의 하위 집합 (트리 내의 부분 집합)

## 이진 트리

- 자식의 노드 수가 두 개 이하인 트리
- 종류

  ![2](https://github.com/MaryJo-github/CS-Study/assets/42026766/4e741b85-2618-4ac6-a173-ba5819868998)
    
    - 정이진 트리(full binary tree): 자식 노드가 0 또는 두 개인 이진 트리
    - 완전 이진 트리(complete binary tree): 왼쪽에서부터 채워져 있는 이진 트리
    마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져있으며, 마지막 레벨의 경우 왼쪽부터 채워져 있음
    - 변질 이진 트리(degenerate binary tree): 자식 노드가 하나밖에 없는 이진 트리
    - 포화 이진 트리(perfect binary tree): 모든 노드가 꽉 차 있는 이진 트리
    - 균형 이진 트리(balanced binary tree): 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리
    map, set을 구성하는 레드 블랙 트리는 균형 이진 트리 중 하나

## 이진 탐색 트리(BST, Binary Search Tree)

- 노드의 오른쪽 하위 트리에는 ‘노드 값보다 큰 값’이 있는 노드만 포함되고, 왼쪽 하위 트리에는 ‘노드 값보다 작은 값’이 들어 있는 트리
- 탐색에 보통 O(logn)이 걸리나, 최악의 경우 O(n)
    - 이진 탐색 트리는 삽입 순서에 따라 선형적일 수 있기 때문
        
      ![3](https://github.com/MaryJo-github/CS-Study/assets/42026766/ff9003de-1aa8-47f9-b52b-de316a4ca820)
  

## AVL 트리(Adelson-Velsky and Landis tree)

- 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 `이진 탐색 트리`
- 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1
- 삽입, 삭제를 할 때마다 높이 차이가 1보다 커지는지 확인하고 회전(rotation)을 통해 균형을 잡음
- AVL 트리는 높이를 logN으로 유지하기 때문에 삽입, 검색, 삭제의 시간 복잡도는 O(logN)
- Balance Factor(BF)
Balance Factor(k) = height(left(k)) - height(right(k))

  ![4](https://github.com/MaryJo-github/CS-Study/assets/42026766/7556f592-2b5e-41a8-ba08-32d7f1a4bebe)

## 레드 블랙 트리

- 균형 이진 탐색 트리
- 탐색, 삽입, 삭제의 시간 복잡도는 O(logn)
- 각 노드는 빨간색 또는 검은색 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는데 사용됨
- “모든 리프 노드와 루프 노드는 블랙이고 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다” 등의 규칙을 기반으로 균형을 잡음

  ![5](https://github.com/MaryJo-github/CS-Study/assets/42026766/6b508950-d187-41c9-a5a4-6b8ec6477917)

# 힙

- 완전 이진 트리 기반의 자료 구조
- 종류
    - 최대힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 함
    각 노드의 자식 노드와의 관계도 위 특징이 재귀적으로 이뤄져야 함
    - 최소힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 작아야 함
    각 노드의 자식 노드와의 관계도 위 특징이 재귀적으로 이뤄져야 함

## 최대힙의 삽입

- 힙에 새로운 요소가 들어오면, 새로운 노드를 힙의 마지막 노드에 이어서 삽입
이 새로운 노드를 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족시킴

## 최대힙의 삭제

- 루트 노드와 마지막 노드를 스왑하고, 마지막 노드(기존의 루트 노드)를 삭제
힙의 성질을 만족시키도록 크기를 비교하며 교환

# 우선순위 큐

- 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조
- 힙을 기반으로 구현

# 맵

- 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조
- 레드 블랙 트리 자료 구조를 기반으로 형성되고, 삽입하면 자동으로 정렬됨

# 셋(set)

- 특정 순서에 따라 고유한(unique) 요소를 저장하는 컨테이너
- 중복 요소 없음

# 해시 테이블

- 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블
→ 작은 크기의 캐시 메모리로도 프로세스를 관리하도록 할 수 있음
- 삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간 복잡도
