# Section 5.2 선형 자료 구조

- 요소가 일렬로 나열되어 있는 자료 구조

## 5.2.1 연결리스트

- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조
- 삽입, 삭제 O(1)
- 탐색 O(n)
- prev 포인터와 next 포인터로 앞과 뒤의 노드를 연결 시킨 것
- 맨 앞 노드 → 헤드(head)
- 종류
    - 싱글 연결 리스트: next
    - 이중 연결 리스트: prev, next
    - 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next가 head를 가리킨다.

## 5.2.2 배열(Array)

- 같은 타입의 변수들로 이루어진 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 크기가 정해져 있고, 중복을 허용하며, 순서가 있다.
(정적 배열 기반)
- 탐색 O(1) - 랜덤 접근 가능
- 삽입, 삭제 O(n)
    
    ⇒ 데이터 추가와 삭제를 많이 하면 연결 리스트, 탐색을 많이하면 배열
    
- 인덱스에 해당하는 원소를 빠르게 접근해야 하거나 간단하게 데이터를 쌓고 싶을 때 사용

### 랜덤 접근과 순차적 접근

- 랜덤 접근(직접 접근)은 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
    
    → 데이터를 저장된 순서대로 검색해야 하는 순차적 접근과는 반대
    

### 배열과 연결 리스트 비교

- 배열 - 상자를 순서대로 나열한 데이터 구조. 
          몇 번째 상자인지만 알면 해당 상자의 요소를 꺼낼 수 있다.
- 연결 리스트 - 상자를 선으로 연결한 형태의 데이터 구조. 
                     상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해봐야 한다.
- 탐색 - 배열 빠르고, 연결 리스트 느림
- 추가, 삭제 - 연결 리스트 느리고, 배열 빠름
(배열: 모든 상자를 앞으로 옮겨야 추가 가능, 연결리스트: 선을 바꿔서 연결해주기만 하면 가능)

## 5.2.3 벡터(Vector)

- 동적으로 요소를 할당할 수 있는 동적 배열
    - 그러면 swift에서 쓰는 배열은 사실 벡터인걸까
- 컴파일 시점에 개수를 모른다면 벡터
- 중복 허용, 순서 있고, 랜덤 접근 가능
- 탐색, 맨 뒤 요소 삭제와 삽입 O(1)
- 맨 뒤나 맨 앞이 아닌 요소 삭제와 삽입 O(n)

## 5.2.4 스택(Stack)

- LIFO(Last In First Out) 성질을 가진 자료 구조
- 삽입, 삭제 O(1)
- 탐색 O(n)
- 재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 쓰임

## 5.2.5 큐(Queue)

- FIFO(First In First Out) 성질을 가진 자료 구조
- 삽입, 삭제 O(1)
- 탐색 O(n)
- CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용
