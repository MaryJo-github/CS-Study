# 인덱스

- 데이터를 빠르게 찾을 수 있도록 도와주는 장치

# B-트리

- 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있음
- 루프 노트, 브랜치 노드, 리프 노드

## 인덱스가 효율적인 이유

- 효율적으로 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성
    - 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것.
    기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스의 항목의 수는 4배씩 증가.

# 인덱스 만드는 방법

- 데이터베이스마다 다름

# 인덱스 최적화 기법

- 데이터베이스마다 조금씩 다르지만 기본적인 골조는 동일

## 1. 인덱스는 비용이다

- 인덱스를 사용하면 인덱스 리스트, 컬렉션 순으로 탐색하기 때문에 관련 읽기 비용이 듦
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 함 (ex. 책의 본문이 수정되었을 때 목차를 수정하듯이)
이 때 B-트리의 높이를 균형 있게 조절하는 비용과, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 듦
- 그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 안됨
컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적

## 2. 항상 테스팅하라

- 인덱스 최적화 기법은 서비스 특징(객체의 깊이, 테이블의 양)에 따라 달라짐
인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야함

## 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

- 보통 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데, 이 인덱스는 순서가 있고, 생성 순서에 따라 인덱스 성능이 달라짐
같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 함
    - 카디널리티: 유니크한 값의 정도(ex. age와 email 중 email이 카디널리티가 더 높음)
