## Section 2.5 HTTP

애플리케이션 계층

### 2.5.1 HTTP/1.0

- 한 연결당 하나의 요청을 처리하도록 설계 → RTT 증가
(3-way handshake를 반복하기 때문)
    
    <aside>
    💡 RTT(Round Trip Time): 패킷 왕복 시간
    
    </aside>
    
- RTT 증가 해결 방법 - 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩
    - 이미지 스플리팅
    → 많은 이미지가 합쳐 있는 하나의 이미지를 다운 받아서
    `background-image`의 `position`을 이용
        
        (swift에 이 기능이 있으려나?🤔)
        
    - 코드 압축 → 개행 문자, 빈칸 삭제로 코드 크기 최소화
    - 이미지 Base64 인코딩
    → 이미지를 64진법으로 이루어진 문자열로 인코딩
    서버에 HTTP 요청을 할 필요가 없는 장점.
    크기가 더 커지는 단점.

### 2.5.2 HTTP/1.1

`keep-alive` 옵션 → 여러 개의 파일 송수신 가능

(HTTP/1.0에서는 표준화가 되어 있지 않았고 1.1에서 기본 옵션으로.)

장점 : 3-way handshake 한 번

단점 : 요청할 리소스 개수에 비례해 대기 시간이 길어진다.

- HOL Blocking(Head Of Line Blocking)
    - 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
        
- 무거운 헤더 구조
    - 헤더에 쿠키 등 많은 메타데이터가 들어 있고, 압축이 되지 않아 무겁다.

### 2.5.3 HTTP

지연시간을 줄이고 응답시간을 더 빠르게 할 수 있으며, 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원

- 멀티플렉싱
    - 여러 개의 스트림을 사용하여 송수신
    (* 스트림(stream): 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름)
    - 특정 스트림의 패킷이 손실되어도 나머지 동작 가능
    
    - 스트림들을 통해 데이터 서빙. 스트림 내 데이터도 쪼개져 있다.
    애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 송수신.
    이후 다시 조립하며 데이터 주고받.
    
    → HOL Blocking 해결
    
- 헤더 압축
    
    - 허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식
    - 허프만 코딩(huffman coding):
    문자열을 문자 단위로 쪼개 빈도가 높은 정보는 적은 비트 수를 사용하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 전체 데이터의 표현에 필요한 비트양을 줄인다.
- 서버 푸시
    
    클라이언트 요청 없이 서버가 바로 리소스를 푸시 가능
    

### 2.5.4 HTTPS

HTTP/2는 HTTPS 위에서 동작.

HTTPS: 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청

이를 통해 `통신을 암호화` 한다.

- SSL/TLS
    - SSL(Secure Socket Layer) → 1.0, 2.0, 3.0
    TLS(Transport Layer Security Protocol) → 1.0, 1.3
    이를 합쳐 SSL/TLS로 많이 부른다.
    
    - SSL/TLS은 전송 계층에서 보안을 제공하는 프로토콜
    - 네트워크상의 `인터셉터`방지
    - 보안 세션을 기반으로 데이터 암호화.
    인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘 사용
    - 보안 세션 - 보안 시작부터 끝나는 동안 유지되는 세션
    SSL/TLS는 핸드셰이크를 통해 보안 세션 생성.
    이를 기반으로 상태 정보 등 공유
    
    - 클라이언트와 서버가 키를 공유
    인증, 인증 확인 등의 작업의 1-RTT 이후 데이터 송수신
    - 클 → 서 : 사이퍼 슈트(cypher suites) 전달
    서 : 사이퍼 슈트의 암호화 알고리즘 리스트 제공 가능 여부 확인
    제공 가능하면 인증 메커니즘 시작 : 서 → 클
    이 후 해싱 알고리즘 등으로 암호화된 데이터 송수신
        - 사이퍼 슈트
        프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약
        - AEAD 사이퍼 모드
        데이터 암호화 알고리즘
    - 인증 메커니즘
    CA(Certificate Authorities)에서 발급한 인증서 기반
    공개키를 클라이언트에 제공, 서버가 신뢰할 수 있는 서버임을 보장
    인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어짐
        - CA 발급 과정
            
            자신의 사이트 정보와 공개키를 CA에 제출
            → CA는 공개키를 해시한 값인 지문(finger print)을 사용하는 CA의 비밀키 등을 기반으로 CA 인증서 발급
            
    - 암호화 알고리즘
        
        ECDHE(Elliptic Curve Diffie-Hellman Ephermeral) - 대수곡선 기반
        DHE(Diffie-Hellman Ephermeral) - 모듈식 기반
        둘 다 디피-헬만(Diffie-Hellman) 방식이 근간
        
        - 디피-헬만 키 교환 암호화 알고리즘
            
            $$
            y = g^x mod_{} p
            $$
            
            g, x, p를 알면 y 구하기 쉽지만 g, y, p만 안다면 x 구하기는 어렵다
            는 원리에 기반한 알고리즘
            
    - 해싱 알고리즘
    데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘
    SSL/TLS는 해싱 알고리즘으로 SHA-256, SHA-384 이용
        - SHA-256
        해시 함수의 결괏값이 256비트인 알고리즘.
        해싱을 해야하는 메시지에 1을 추가하는 등 전처리
        → 전처리된 메시지를 기반으로 해시 반환
- SEO에도 도움이 되는 HTTPS
    - 구글 공식 발표!
    사이트 내 모든 요소가 동일하다면 HTTPS 서비스를 하는 사이트가 SEO 순위가 더 높을 것이다.
    - SEO(Search Engine Optimization): 검색엔진 최적화
    → 검색엔진으로 웹사이트를 검색했을 때 그 결과를 페이지 상단에 노출시켜 많은 사람이 볼 수 있도록 최적화
    → 캐노니컬 설정, 메타 설정, 페이지 속도 개선, 사이트맵 관리 등을 활용
- HTTPS 구축 방법
    - 직접 CA에서 구매한 인증키 기반으로 HTTPS 서비스 구축
    - 서버 앞단의 HTTPS를 제공하는 로드밸랜서로 구축
    - 서버 앞단에 HTTPS를 제공하는 CDN으로 구축

### 2.5.5 HTTP

HTTP/1.1, HTTP/2와 함께 World Wide Web에서 정보를 교환하는 데 사용됨

QUIC 계층 위에서 돌아가며, UDP 기반

초기 연결 설정 시 지연 시간 감소
→ TCP 사용X, 따라서 3-way handshake 과정 X

- QUIC
    - 첫 연결 설정에 1-RTT 소요
    - 순방향 오류 수정 메커니즘(FEC, Forword Error Correction) 적용
    전송한 패킷이 손실되었다면 수신측에서 에러를 검출하고 수정하는 방식
    낮은 패킷 손실률 자랑
