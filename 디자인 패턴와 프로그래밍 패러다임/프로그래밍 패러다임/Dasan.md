# 프로그래밍 패러다임

- 프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론
- 프로그래밍 패러다임의 분류
  - 선언형 
      - 함수형
  - 명령형
      - 객체지향형
      - 절차지향형

<br>

## 📍 선언형과 함수형 프로그래밍
### 선언형 프로그래밍(declarative programming)
- **‘무엇을’** 풀어내는가에 집중하는 패러다임
- “프로그램은 함수로 이루어진 것이다” 라는 명제가 담겨 있는 패러다임
- 어떤 방법으로 해야하는지를 나타내기보다 무엇과 같은지를 설명하는 경우

### 함수형 프로그래밍(functional programming)
- 선언형 패러다임의 일종
- `순수 함수`들을 블록처럼 쌓아 로직을 구현하고, `고차 함수`를 통해 재사용성을 높인 프로그래밍 패러다임
- 이외에도 커링, 불변성 등 많은 특징이 있음
- 장점
    - 테스트와 디버깅이 용이하다
    - 더 나은 모듈화와 짧은 코드를 제공한다
    - 코드 재사용이 쉽다
    - 프로그램의 동작을 예측하기 쉽다
- 단점
    - 개념을 이해하기 쉽지 않다
    - 프로그래밍을 진행하며 수 많은 함수들을 파악하고 유지 관리하기 힘들어진다
    - 함수가 많아질수록 함수를 조합하기 복잡해진다

#### 순수 함수
- **출력이 입력에만 의존**하는 것을 의미

```jsx
const pure = (a, b) => {
	return a + b
}
```

#### 고차함수
- **함수가 함수를 값처럼** 매개변수로 받아 로직을 생성할 수 있는 것

#### 일급 객체
- 고차 함수를 쓰기 위해서는 해당 언어가 일급 객체라는 특징을 가져야하며, 그 특징은 다음과 같음
    - **변수나 메서드에 함수를 할당**할 수 있음
    - 함수 안에 **함수를 매개변수로** 담을 수 있음
    - **함수가 함수를 반환**할 수 있음

<br>

## 📍객체지향 프로그래밍
- 객체지향 프로그래밍(OOP, Object-Oriented Programming)은 **객체들의 집합으로 프로그램의 상호 작용을 표현**하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말함
- 장점
    - 다형성을 통해 재사용성을 높일 수 있음
    - 생산성 향상
    - 자연적인 모델링(일상생활의 모습의 구조가 객체에 녹아들어있기 때문에 자연스럽게 구현 가능)
    - 유지보수의 우수성
- 단점
    - 설계에 많은 시간이 소요됨
    - 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느림

<br>

### 🔎 객체지향 프로그래밍의 특징
- 추상화(abstraction)
  - 복잡한 시스템으로부터 **핵심적인 개념 또는 기능을 간추려내는 것**
  - 공통 특성 중 관심있는 부분만 추출하고 나머지는 무시하는 과정
cf. 일반화(generalization): 여러 인스턴스의 공통 특징을 뽑아 내는 것

- 캡슐화(encapsulation)
  - 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것

- 상속성(inheriance)
  - 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것
  - 코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요

- 다형성(polymorphism)
  - 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말함
  - 대표적으로 오버로딩, 오버라이딩이 있음
    - 오버로딩(overloading)
        - 같은 이름을 가진 메서드를 여러 개 두는 것을 말함
        - 메서드의 타입, 매개변수의 유형, 개수 등으로 여러 개를 둘 수 있음
        - 컴파일 중에 발생하는 `정적` 다형성
    - 오버라이딩(overriding)
        - 주로 메서드 오버라이딩을 말하며 **상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의**하는 것을 의미
        - 이는 런타임 중에 발생하는 `동적` 다형성

<br>

### 🔎 설계 원칙
객체지향 프로그래밍을 설계할 때는 SOLID 원칙을 지켜야함

- SRP, 단일 책임 원칙(Single Responsibility Principle)
  - 모든 **클래스는 각각 하나의 책임만 가져야**하는 원칙
  - 예를 들어 A라는 로직이 존재한다면 어떠한 클래스는 A에 관한 클래스여야하고 이를 수정한다고 했을 때도 A와 관련된 수정이어야 함

- OCP, 개방-폐쇄 원칙(Open Closed Principle)
  - 유지 보수 사항이 생긴다면 코드를 **쉽게 확장**할 수 있도록 하고 **수정할 때는 닫혀 있어야** 하는 원칙
  - 즉, 기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 함

- LSP, 리스코프 치환 원칙(Liskov Substitution Principle)
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 **하위 타입의 인스턴스로 바꿀 수 있어야 하는 것**을 의미
  - 클래스는 상속이 되기 마련이고 부모, 자식이라는 계층 관계가 만들어집니다. 이때 **부모 객체에 자식 객체를 넣어도 시스템이 문제 없이 돌아가게  만드는 것**을 말합니다.

- ISP, 인터페이스 분리 원칙(Interface Segregation Principle)
  - 하나의 일반적인 인터페이스보다 **구체적인 여러 개의 인터페이스를 만들어야** 하는 원칙

- DIP, 의존 역전 원칙(Dependency Inversion Principle)
  - 자신보다 변하기 쉬운 것에 의존하던 것을 **추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙**
  - 즉, 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 합니다.

<br>

### 🔎 POP(Protocol Oriented Programming)
- 객체 지향 프로그래밍의 한 형태로, 프로토콜을 중심으로 하는 개발 패러다임
- OOP의 클래스는 암시적 공유로 인한 버그, 단일 상속으로 인한 비대한 상속, 특정 문제 도메인에 적합하지 않은 단점이 있었음
- 프로토콜은 이러한 문제를 해결하는 대안으로, 공유 제어의 능력을 향상시키고 더 유연한 추상화와 타입 안정성을 제공
- 프로토콜을 채택함으로써 개발자는 더 유연하고 확장 가능하며 유리 관리가 용이한 코드베이스를 구축할 수 있음

<br>

## 📍절차형 프로그래밍
- 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있음
- 장점
    - 일이 진행되는 방식으로 그저 코드를 구현하기만 하면 되기 때문에 코드의 가독성이 좋으며 실행 속도가 빠름
    - 따라서 계산이 많은 작업 등에 쓰임
- 단점
    - 모듈화하기가 어렵고
    - 유지 보수성이 떨어짐

<br>

---

### 🔎 선언형 프로그래밍 vs 명령형 프로그래밍

|  | 선언형 | 명령형 |
| --- | --- | --- |
|  | 목표를 명시하고 알고리즘을 명시하지 않음 | - 알고리즘을 명시하고 목표는 명시하지 않음<br>- 상태 변경을 다루는데 중점을 둠(상태에 의존) |
|  | 무엇을 할 것인가(무엇을 원하는가) (WHAT) | 무엇을 어떻게 할 것인가 (HOW) |
| 종류 | - 함수형 프로그래밍 <br>- 논리형 프로그래밍 | - 객체지향 프로그래밍<br>- 절차지향 프로그래밍 |
| 장점 | - (수행하는 방법 대신 프로그램에서 수행할 작업을 선언하기 때문에) 가독성 향상 및 의도 표현 강화<br>-코드의 재사용 증가<br>- 병렬 처리 용이 | - 유연성과 직관성<br>- 하드웨어의 동작에 가까워질 수 있어 효율적인 코드를 작성하는데 용이<br>- 직접적인 제어 |
| 단점 | - 때로는 외부인이 이해하기 어려울 수 있음<br>- 추상화 수준이 높기 때문에 불필요한 오버헤드가 발생할 수 있음<br>- 일부 문제에 대한 비효율성 | - 가독성 감소<br>- 복잡성 증가<br>- 병렬화 어려움<br>- 상태 관리 어려움 |

---

<br>

## 📍패러다임의 혼합

- 비지니스 로직이나 서비스의 특징을 고려해서 패러다임을 정하는 것이 좋다
- 하나의 패러다임을 기반으로 통일하여 서비스를 구축하는 것도 좋은 생각이지만 여러 패러다임을 조합하여 상황과 맥락에 따라 패러다임 간의 장점만 취해 개발하는 것이 좋음
